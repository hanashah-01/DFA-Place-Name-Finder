# -*- coding: utf-8 -*-
"""place-finder.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Y1tP0lduKItuWHLArusxVzymmz5b0EFn

# Recognizer Deterministic Finite Automata (DFA) For Places

This Python DFA simulator is designed to perform string-searching using patterns related to world regions, sub-regions, countries, and states.
"""

#import the standard modules
import pandas as pd
import warnings
import textwrap
import os
warnings.filterwarnings('ignore')

#read the files that contain regions, sub-regions, countries, and states in the world
regions = pd.read_csv("/data/regions.csv")
subregions = pd.read_csv("/data/subregions.csv")
countries = pd.read_csv("/data/countries.csv")
states = pd.read_csv("/data/states.csv")
seas = pd.read_csv("/data/seas.csv")

#convert dataframes to lists and concatenate them
regions_list = regions['name'].values.tolist()
subregions_list = subregions['name'].values.tolist()
countries_list = countries['name'].values.tolist()
states_list = states['name'].values.tolist()
seas_list = seas['name'].values.tolist()
places_list = regions_list + subregions_list + countries_list + states_list + seas_list
print(places_list)

#alphabet for the DFA
NO_OF_CHARS = 256

def getNextState(pat, M, state, x):
    '''
    Calculate the next state
    '''
    # If the character c is same as next character
    # in pattern, then simply increment state
    if state < M and x == ord(pat[state]):
        return state + 1

    # ns stores the result which is next state

    # ns finally contains the longest prefix
    # which is also suffix in "pat[0..state-1]c"

    # Start from the largest possible value and
    # stop when you find a prefix which is also suffix
    for ns in range(state, 0, -1):
        if ord(pat[ns - 1]) == x:
            i = 0
            while i < ns - 1:
                if pat[i] != pat[state - ns + 1 + i]:
                    break
                i += 1
            if i == ns - 1:
                return ns
    return 0

def computeTF(pat, M):
    '''
    Build the TF table which represents Finite Automata for a given pattern
    '''
    #initialize a 2D list representing the transition table where NO_OF_CHARS is the number of columns
    #and M+1 is the number of rows
    TF = [[0 for _ in range(NO_OF_CHARS)] for _ in range(M + 1)]

    #populate the transition table
    for state in range(M + 1):
        for x in range(NO_OF_CHARS):
            z = getNextState(pat, M, state, x)
            TF[state][x] = z
    return TF

def countTransitions(TF):
    '''
    Count the number of transitions in the TF table
    '''
    count = 0
    for row in TF:
        for cell in row:
            if cell != 0:
                count += 1
    return count

def countStates(TF):
    '''
    Count the number of states in the TF table
    '''
    unique_states = set()
    for state in TF:
        if any(state):
            unique_states.add(tuple(state))
    return len(unique_states)

def countFinalStates(TF, M):
    '''
    Identify and count final states in the TF table
    '''
    final_states = set()
    for state in range(M + 1):
        if state == M or TF[state][0] == M:
            final_states.add(state)
    return len(final_states)

def calculateDFAProperties(patterns):
    '''
    Calculate transitions, states and final states for the DFA
    '''
    total_transitions = 0
    total_final_states = 0
    total_states = 0

    for pat in patterns:
        M = len(pat)
        TF = computeTF(pat, M)

        num_transitions = sum(sum(1 for cell in row if cell != 0) for row in TF)
        num_final_states = len({state for state in range(M + 1) if state == M or TF[state][0] == M})
        num_states = countStates(TF)

        total_transitions += num_transitions
        total_final_states += num_final_states
        total_states += num_states

    return total_transitions, total_final_states, total_states

def search_patterns_in_text(patterns, text):
    '''
    Search for place names in the given text
    '''
    global NO_OF_CHARS
    N = len(text)
    status = 0

    for pat in patterns:
        M = len(pat)
        TF = computeTF(pat, M)
        state = 0

        i = 0
        while i < N:
            state = TF[state][ord(text[i])]
            if state == M:
                status += 1
                print("Pattern '{}' found at index: {}".format(pat, i - M + 1))

                # Calculate start and end indices for context display
                start_idx = max(0, i - M - 5)
                end_idx = min(N, i + 5)

                # Display context surrounding the matched string
                for j in range(start_idx, end_idx):
                    if j >= i - M and j <= i:  # Highlight the matched string
                        print('\033[32m', text[j], end="")
                    else:
                        print('\033[0m', text[j], end="")

                # Check if the matched string is at the end of a sentence
                if i + 1 < N and text[i + 1] in ['.', '?', '!']:
                    print("\n")  # Add newline after sentence end
                    break  # Exit the loop if sentence ends after the match
                else:
                    print("\n")
            i += 1  # Increment i to move to the next character in text

    if status == 0:
        print("No pattern found")
        print("Status: Rejected. No place names detected in the text.")
    else:
        print("\n")
        print("Total occurrences of pattern:", status)
        print("Status: Accepted. "+ str(status) +" place name(s) detected in the text.")

def main():
    patterns = places_list

    print("***************************")
    print("*  PLACE NAME RECOGNIZER  *")
    print("***************************")
    text = input("Enter text: ")
    print("\nText:")
    print(textwrap.fill(text, width=100))
    print("\n")
    search_patterns_in_text(patterns, text)
    total_transitions, total_final_states, total_states = calculateDFAProperties(patterns)
    print("\nDFA Properties:")
    print("Total Transitions:", total_transitions)
    print("Total States:", total_states)
    print("Total Final States:", total_final_states)

if __name__ == '__main__':
    main()